# version: "3.8"

# services:
#   postgres:
#     image: postgres:17
#     container_name: mdm_postgres
#     restart: unless-stopped
#     environment:
#       POSTGRES_USER: mdmpostgres
#       POSTGRES_PASSWORD: mdmpostgres
#       POSTGRES_DB: mdmDB
#     ports:
#       - "5438:5432"
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U mdmpostgres -d mdmDB || exit 1"]
#       interval: 5s
#       timeout: 3s
#       retries: 10
#     volumes:
#       - pgdata:/var/lib/postgresql/data

#   redis:
#     image: redis:7-alpine
#     container_name: redis
#     restart: unless-stopped
#     ports:
#       - "6379:6379"
#     # If you want authentication in dev, you can set REDIS_PASSWORD and pass it via command:
#     # environment:
#     #   REDIS_PASSWORD: yourpassword
#     command: ["redis-server", "--requirepass", "${REDIS_PASSWORD}"]
#     healthcheck:
#       # Uses redis-cli PING; requires redis-tools inside image (available in official redis image)
#       test: ["CMD", "redis-cli", "ping"]
#       interval: 5s
#       timeout: 3s
#       retries: 10
#     volumes:
#       - redisdata:/data

# volumes:
#   pgdata:
#   redisdata:

version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    container_name: mdm_postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: "${POSTGRES_USER:-mdmpostgres}"
      POSTGRES_PASSWORD: "${POSTGRES_PASSWORD:-mdmpostgres}"
      POSTGRES_DB: "${POSTGRES_DB:-mdmDB}"
    ports:
      - "${HOST_POSTGRES_PORT:-5438}:5432"        # map if you need host access; set HOST_POSTGRES_PORT empty to avoid mapping
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-mdmpostgres} -d ${POSTGRES_DB:-mdmDB} || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10

  redis:
    image: redis:7-alpine
    container_name: mdm_redis
    restart: unless-stopped
    command: >
      sh -c '
        # Optional: start with requirepass if REDIS_PASSWORD provided
        if [ -n "$$REDIS_PASSWORD" ]; then
          exec redis-server --requirepass "$$REDIS_PASSWORD"
        else
          exec redis-server
        fi
      '
    environment:
      # REDIS_PASSWORD will be read from .env if set (optional)
      REDIS_PASSWORD: "${REDIS_PASSWORD:-}"
    ports:
      - "${HOST_REDIS_PORT:-6379}:6379"           # map if you need host access; set HOST_REDIS_PORT empty to avoid mapping
    volumes:
      - redisdata:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 10

  api:
    build: .
    container_name: mdm_api
    depends_on:
      - postgres
      - redis
    environment:
      NODE_ENV: "${NODE_ENV:-production}"
      PORT: "${PORT:-4000}"
      DATABASE_URL: "${DATABASE_URL}"
      REDIS_URL: "${REDIS_URL:-redis://redis:6379}"
      JWT_SECRET: "${JWT_SECRET:-change_me}"
      STREAM_KEY: "${STREAM_KEY:-notifications:stream}"
      STREAM_DGROUP: "${STREAM_DGROUP:-notifications:group}"
      STREAM_DLG: "${STREAM_DLG:-notifications:dlq}"
      CONSUMER_NAME: "${CONSUMER_NAME:-worker-1}"
      MAX_RETRY: "${MAX_RETRY:-5}"
      FRONTEND_ORIGIN: "${FRONTEND_ORIGIN:-http://localhost:3000}"
    ports:
      - "${HOST_API_PORT:-4000}:4000"
    restart: on-failure
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:4000/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  outbox-worker:
    build: .
    container_name: mdm_outbox_worker
    command: npm run start:worker:outbox
    depends_on:
      - postgres
      - redis
    environment:
      NODE_ENV: "${NODE_ENV:-production}"
      DATABASE_URL: "${DATABASE_URL}"
      REDIS_URL: "${REDIS_URL:-redis://redis:6379}"
      STREAM_KEY: "${STREAM_KEY:-notifications:stream}"
      STREAM_DGROUP: "${STREAM_DGROUP:-notifications:group}"
      STREAM_DLG: "${STREAM_DLG:-notifications:dlq}"
      CONSUMER_NAME: "${CONSUMER_NAME:-worker-1}"
      MAX_RETRY: "${MAX_RETRY:-5}"
    restart: on-failure

  notification-worker:
    build: .
    container_name: mdm_notification_worker
    command: npm run start:worker:notification
    depends_on:
      - postgres
      - redis
    environment:
      NODE_ENV: "${NODE_ENV:-production}"
      DATABASE_URL: "${DATABASE_URL}"
      REDIS_URL: "${REDIS_URL:-redis://redis:6379}"
      STREAM_KEY: "${STREAM_KEY:-notifications:stream}"
      STREAM_DGROUP: "${STREAM_DGROUP:-notifications:group}"
      STREAM_DLG: "${STREAM_DLG:-notifications:dlq}"
      CONSUMER_NAME: "${CONSUMER_NAME:-worker-1}"
      MAX_RETRY: "${MAX_RETRY:-5}"
    restart: on-failure
    # scale this worker (e.g. docker-compose up --scale notification-worker=2) for throughput

  eventbus-worker:
    build: .
    container_name: mdm_eventbus_worker
    command: npm run start:worker:eventbus
    depends_on:
      - redis
    environment:
      NODE_ENV: "${NODE_ENV:-production}"
      REDIS_URL: "${REDIS_URL:-redis://redis:6379}"
    restart: on-failure

  stream-reclaimer:
    build: .
    container_name: mdm_stream_reclaimer
    command: npm run start:worker:reclaimer
    depends_on:
      - redis
    environment:
      NODE_ENV: "${NODE_ENV:-production}"
      REDIS_URL: "${REDIS_URL:-redis://redis:6379}"
      STREAM_KEY: "${STREAM_KEY:-notifications:stream}"
      STREAM_DGROUP: "${STREAM_DGROUP:-notifications:group}"
      CONSUMER_NAME: "${CONSUMER_NAME:-worker-1}"
    restart: on-failure

volumes:
  pgdata:
  redisdata:
